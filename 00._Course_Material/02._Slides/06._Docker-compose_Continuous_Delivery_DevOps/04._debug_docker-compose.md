<div class="title-card">
    <h1>Debug docker-compose</h1>
</div>

---

# Let's set up a Node.js project

1. Create a folder called `05._Debug_Docker`.

2. Inside of it create a folder called `app`.

3. In the `app` folder run the following commands:

```bash
$ npm init -y
$ npm install express
```

In the top-level of package.json change to `type: module`.

---

# Let's create a simple Express server

Inside of `app` create a file called `app.js` which should contain the following:

```javascript
import express from 'express';
const app = express();

app.get('/', (req, res) => {
    res.send({ data: 'Hello World!'});
});

app.listen(80, () => {
    console.log('App running on port 80');
});
```

---

# Create the faulty `Dockerfile`

Inside of the `app` folder create a `Dockerfile` and add the following:

```Dockerfile
FROM node

WORKDIR /app

COPY package*.json ./

RUN npm install

COPY . .

CMD ["npm", "start"]
```

---

# Create the faulty `docker-compose.yml`

Outside of the `app` directory create a `docker-compose.yml`:

```yaml
services:
  app:
    build:
      context: ./app
      dockerfile: Dockerfile
    ports:
      - "3000:80"
    networks:
      - app_net

  db:
    image: postgres
    environment:
      POSTGRES_USER: root
      POSTGRES_PASSWORD: pass123
    networks:
      - db_net

networks:
  app_net:
    driver: bridge
  db_net:
    driver: bridge
```

---

# Let's run it

```bash
$ docker compose up --build
```

---

# Did it start?

*Is the process running? How do we check the logs?*

*How would you do it with `docker`?*

**Cool Trick**: Instead of running Docker commands with `docker` which will inform us of all containers, we can cd to the where the docker-compose file is and run `docker compose <command>` which will only inform us of the containers defined in the docker-compose file.

We can then find out about specific containers by their service name as defined in the docker-compose file: `app` and `db`.

---

# Are they running? How do we check the logs?

Try to compare these two commands:

```bash
$ docker compose ps
$ docker compose ps -a
```

Checking the logs of a specific service:

```bash
$ docker compose logs <service_name>
```

For example:

```bash
$ docker compose logs app
```

---

# You might've noticed it when running `docker compose up --build`

But the it doesn't run because it expect to find a start script in `package.json`.

Add it:

```json
"scripts": {
  "start": "node app.js"
}
```

Run `docker-compose up --build` again and check if it's running.

```bash
$ docker compose ps
```

---

# Is it running?

Try to access it from `localhost:80`. *Does it work?*

Let's check the logs again:

```bash
$ docker compose logs app
$ docker compose logs db
```

There doesn't seem to be any startup errors. It's running as it should on port `80`.


---

# Verify what ports have been opened in the container

Use `netstat` to find open ports inside the container:

```bash
$ docker compose exec app netstat -tuln
```

That wasn't helpful. We could also use Docker to tell us which ports have been opened.

```bash
$ docker ps --format "{{.Names}}: {{.Ports}}"
```


<details> 
  <summary>Spoiler</summary>
   The external port `3000` points to the internal port: `80`. Access it the application via `localhost:3000`.
</details>

---

# Let's see if the environment variables work 

In `app.js`, change the route to the following:

```javascript
app.get('/', (req, res) => {
  res.send({ data: `Hello from the ${process.env.NODE_ENV} environment` });
});
```

Where has the `NODE_ENV` environment variable been set? What do we expect it to be?

Rerun `docker compose up --build` and check in the browser if it works. 

---

# It doesn't work

In the browser it says:

```json
{
  "data": "Hello from the undefined environment"
}
```

Let's see if the environment variable is set in the container.

```bash
$ docker compose exec  app env | grep NODE_ENV
```

---

# We have not defined the environment variable

In the `docker-compose.yml` file, we can use either:

```yaml
  environment:
      - NODE_ENV=production
```

or with a `.env` file:

```yaml
  env_file:
      - .env
```

Let's use the first since there is nothing sensitive about the environment variable.

Remember to rerun `docker compose up --build` after changing the `docker-compose.yml` file.

---

# Let's test out the database

Install the PostgreSQL driver (`pg`):

```bash
$ npm install pg
```

Add this to the `app.js`:

```javascript
import pkg from 'pg';
const { Pool } = pkg;

const pool = new Pool({
  user: process.env.POSTGRES_USER,
  host: 'db',
  database: 'postgres',
  password: process.env.POSTGRES_PASSWORD,
  port: 5432,
});

pool.query('SELECT NOW()', (err, res) => {
  if (err) {
    console.error(err);
  } else {
    console.log(res.rows[0]);
  }
});
```

---

# First: Let's debug the container

Does it work in the app?

```bash
$ docker compose logs app
```

Verify the containers are running:

```bash
$ docker compose ps
```


Check logs for database startup issues:

```bash
$ docker compose logs db
```

---

# Next: Let's debug the connection

Pre-debug step: Install `ping` in the app container:

```bash
$ docker compose exec app apt-get update
$ docker compose exec app apt-get install -y iputils-ping
```

Test connection between containers (using Dockerâ€™s built-in networking):

```bash
$ docker compose exec app ping db
ping: db: Name or service not known
```

Read the error message below the command. We are **not** able to ping it.

Try connecting manually to the db container:

```bash
$ docker compose exec db psql -h db -U root -d postgres
```

But we *are* able to access the database.

---

# See which networks the containers are connected to

List all networks:

```bash
$ docker network ls
```

Check which networks the containers are connected to:

```bash
$ docker compose exec app sh -c 'hostname -i'
$ docker compose exec db sh -c 'hostname -i'
```

The networks have **different IPs**. They are not connected to the same network.

---

# Simplify the `docker-compose.yml` and let them join the same network

```yaml
services:
  app:
    build:
      context: ./app
      dockerfile: Dockerfile
    ports:
      - "3000:80"
    environment:
      - NODE_ENV=production

  db:
    image: postgres
    environment:
      POSTGRES_USER: root
      POSTGRES_PASSWORD: pass123
```

---

# Problems with the environment variables again

When we rerun with `docker compose up --build` we get this error:

```
error: no PostgreSQL user name specified in startup packet
```

Did we define the database username? Let's look at the the environment variables:

```bash
$ docker compose exec app env
```

*What is the problem? How do we fix it?*


---

# The problem is the environment variables are not set

The db credentials have not been defined as environment variables on the app container. 

There are better solutions that will not require us to push the environment variables but for now let's add them to the docker-compose file:

```yaml
environment:
  - POSTGRES_USER=root
  - POSTGRES_PASSWORD=pass123
```

Rerun it and have a look. It should work now.

*Do you see the timestamp in the app logs?*

---

# A neat trick

Try to run `docker compose` in detached mode:

```bash
$ docker compose up -d --build
```

To stop it, you just need to be where the `docker-compose.yml` file is and run:

```bash
$ docker compose down
```

It will know to stop all the services defined in the `docker-compose.yml` file.

